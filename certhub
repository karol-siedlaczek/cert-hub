#!/usr/bin/env python3

# Karol Siedlaczek 2026

import os
import json
import shlex
import typer
import hmac
import hashlib
import base64
import sys
import binascii
import subprocess
from datetime import datetime, timezone
from enum import Enum
from getpass import getpass
from pathlib import Path
from rich.console import Console
from rich.table import Table, box
from dataclasses import dataclass
from typing import Any, Optional, Dict, Sequence, NoReturn, ClassVar
import requests
from cryptography import x509

ENV_VAR_API_URL = "CERTHUB_API_URL"
ENV_VAR_TOKEN = "CERTHUB_TOKEN"
SETTINGS_FILE = Path("~/.certhub").expanduser()
GLOBAL_FORMAT = None


class ExitCode(Enum):
    OK = 0
    WARNING = 1
    CRITICAL = 2
    UNKNOWN = 3
    

class Format(Enum):
    TABLE = "table"
    JSON = "json"
    KEY_VALUE = "kv"
    VALUE = "value"
    
    @classmethod
    def values(cls) -> list[str]:
        return [item.value for item in cls]
    
    @classmethod
    def default(cls) -> str:
        return Format.TABLE.value


@dataclass
class Settings:
    api_url: str | None
    token: str | None
        
    
class Opt:
    @staticmethod
    def timeout(default: int = 10) -> Any:
        return typer.Option(
            default, "--timeout", "-t",
            help="API request timeout in seconds",
        )

    @staticmethod
    def format(default: str | None = None) -> Any:
        return typer.Option(
            default or Format.default(), "--format", "-f",
            help=f"Output format: {", ".join(Format.values())}",
        )

    @staticmethod
    def columns() -> Any:
        return typer.Option(
            None, "-c", "--column",
            help="Specify the column(s) to include, can be repeated to show multiple columns",
        )

    @staticmethod
    def patterns() -> Any:
        return typer.Option(
            None, "--pattern", "-p",
            help="Certificate pattern, can be specified multiple times. Defaults to all certificates allowed for the current identity",
        )

    @staticmethod
    def force(help_text: str) -> Any:
        return typer.Option(
            None, "--force",
            help=help_text,
        )


app = typer.Typer(
    add_completion=True, 
    help="CLI for managing certificates in Cert Hub"
)
cert_app = typer.Typer(help=f"Certificate commands, use '{sys.argv[0]} cert --help' for details")
token_app = typer.Typer(help=f"Token commands, add '{sys.argv[0]} token --help' for details")
app.add_typer(cert_app, name="cert")
app.add_typer(token_app, name="token")
console = Console()


@app.callback()
def main(
    ctx: typer.Context,
    api_url: str = typer.Option(
        "http://localhost:8080", "--base-url",
        envvar=ENV_VAR_API_URL,
        help=f"API base URL. You can set environment or set API_URL=<value> in {SETTINGS_FILE}",
    ),
    token: str = typer.Option(
        None, "--token",
        envvar=ENV_VAR_TOKEN,
        help=f"Bearer token. You can set environment or set TOKEN=<value> in {SETTINGS_FILE}",
    )
) -> None:
    ctx.obj = Settings(api_url=api_url, token=token)

# Client

@dataclass
class Nagios():
    NSCA_CMD: ClassVar[str] = "/usr/sbin/send_nsca"
    server: str
    hostname: str
    service: str
    format: Format
    
    @classmethod
    def from_options(cls, server: str, hostname: str, service: str, format: Format) -> "Nagios | None":
        if not any((server, hostname, service)):
            return None
            
        if not all([server, hostname, service]):
            raise typer.BadParameter(
                "To send passive check result to Nagios options --nagios-server, --nagios-hostname and --nagios-service must be provided together"
            )
        
        nsca_cmd_path = Path(Nagios.NSCA_CMD)
        
        if not (nsca_cmd_path.exists() and os.access(nsca_cmd_path, os.X_OK)):
            raise typer.BadParameter(
                f"Failed to setup sending passive check results to Nagios: Path '{nsca_cmd_path}' not found or not executable"
            )

        return cls(server, hostname, service, format)
    
    
    def send_passive(self, msg: str, code: ExitCode) -> str:
        cmd = f"echo -e \"{self.hostname}\t{self.service}\t{code.value}\t{msg}\" | {Nagios.NSCA_CMD} -H {self.server}"
        
        result = run_cmd(cmd, shell=True)
        if result.returncode != 0:
            data = {
                "msg": "Failed to send passive check result to Nagios",
                "error": result.stderr,
                "return_code": result.returncode,
                "cmd": cmd
            }
            result = Result(data, ExitCode.CRITICAL)
            return result.render_and_exit()
            
        return result.stdout
    

@dataclass(frozen=True)
class Client():
    base_url: str
    session: requests.Session
    timeout: int
    
    @classmethod
    def init(
        cls, 
        base_url: str, 
        token: Optional[str] = None, 
        *,
        timeout: int, 
        format: Format,
        nagios: Nagios = None
    ) -> "Client":
        base_url = base_url.rstrip("/")
        session = requests.Session()
        
        if token:
            session.headers.update({"Authorization": f"Bearer {token}"})

        session.headers.update({"Accept": "application/json"})
        
        try:
            session.request("GET", f"{base_url}/ping", timeout=10)
        except requests.RequestException as e:
            msg = "Error connecting to API server"
            exit_code = ExitCode.CRITICAL
            
            if nagios:
                nagios.send_passive(f"{exit_code.name}: {msg}, error: {e}", exit_code)
            result = Result({"msg": msg, "error": str(e)}, format, exit_code)
            return result.render_and_exit()
            
        return cls(base_url, session, timeout or 10)
    
    
    def request(
        self, 
        method: str, 
        path: str, 
        *, 
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> requests.Response:
        url = f"{self.base_url}{path}"
        
        response = self.session.request(
            method=method.upper(),
            url=url,
            params=params,
            json=json_body,
            timeout=self.timeout
        )
        
        return response
    

# Commands    
    
@app.command(help="Versions and author")
def version(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    response = client.request("GET", "/api/version")
    
    result = Result(response, format)
    return result.render_and_exit(columns)


@token_app.command(help="Permitted certificates for current identity")
def scope(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    response = client.request("GET", "/api/token/scope")
    
    result = Result(response, format)
    return result.render_and_exit(columns)
    
    
@token_app.command(help="Current identity information (e.g. allowed CIDRs, permissions)")
def identity(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    response = client.request("GET", "/api/token/identity")
    
    result = Result(response, format)
    if result.data.get("permissions"):
        result.data["permissions"] = [f"{p['scope']}:{p['action']}" for p in result.data["permissions"]]
    
    return result.render_and_exit(columns)


@token_app.command(help="Generate TOKEN_<ID>_HMAC value for server configuration") 
def gen_hmac(
    hmac_key_b64: str = typer.Option(
        None, "--hmac-key-b64",
        help="Base64-encoded HMAC key, min length is at least 32 bytes (must match server HMAC_KEY_B64). If not provided, you will be prompted (Recommended)",
    ),
    token_id: str = typer.Option(
        None, "--id", "-i",
        help="Identity ID used as <id> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted",
    ),
    token_value: str = typer.Option(
        None, "--token", "-t",
        help="Raw token value used as <token> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted (Recommended)",
    )
) -> None:
    if token_id is None:
        token_id = input("Token ID: ").strip()
    if hmac_key_b64 is None:
        hmac_key_b64 = getpass("HMAC key (base64): ").strip()
    if token_value is None:
        token_value_1 = getpass("Token value: ").strip()
        token_value_2 = getpass("Confirm token value: ").strip()
        
        if token_value_1 != token_value_2:
            raise typer.BadParameter("Token values do not match")
        
        if not token_value_1:
            raise typer.BadParameter("Token value cannot be empty")
        
        token_value = token_value_1
        
    try:
        hmac_key = base64.b64decode(hmac_key_b64, validate=True)
    except binascii.Error:
        raise typer.BadParameter(
            "Invalid HMAC key: not valid base64.\n"
            "Generate a new one with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )
    
    if len(hmac_key) < 32:
        raise typer.BadParameter(
            "Invalid HMAC key: decoded key must be at least 32 bytes.\n"
            "Generate a secure key with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )

    token = str(token_value).encode()
    hmac_key = hmac.new(hmac_key, token, hashlib.sha256)
    
    typer.secho("\nSuccess!\n", fg=typer.colors.GREEN)
    print("Add the following environment variable to the server:")
    print(f"TOKEN_{token_id.upper()}_HMAC={hmac_key.hexdigest()}\n")


@cert_app.command(help="Statuses for all certificates")
def health(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    exclude_ok: bool = typer.Option(
        None, "--exclude-ok", 
        help="Hide certificates with OK status"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    params = {
        **({"exclude_ok": "true"} if exclude_ok else {}),
        **({"match": patterns} if patterns else {})
    }
    response = client.request("GET", "/api/health", params=params)
    
    result = Result(response, format)
    if result.data.get("certs"):
        result.data = result.data["certs"] 
    
    return result.render_and_exit(columns)
    

@cert_app.command(help="Issue new certificates for the current identity or selected pattern")
def issue(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    force: bool = Opt.force("Force reissue of certificate even if it already exists")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    params = {
        **({"force": "true"} if force else {}),
        **({"match": patterns} if patterns else {})
    }
    response = client.request("POST", "/api/certs/issue", params=params)
    
    result = Result(response, format)
    return result.render_and_exit(columns)


@cert_app.command(help="Renew existing certificates for the current identity or selected pattern")
def renew(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    force: bool = Opt.force("Force certificate renew even if it does not expire")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    params = {
        **({"force": "true"} if force else {}),
        **({"match": patterns} if patterns else {})
    }
    response = client.request("POST", "/api/certs/renew", params=params)
    
    result = Result(response, format)
    return result.render_and_exit(columns)
    

@cert_app.command(help="List certificates available for the current identity or selected pattern")
def get(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format)
    params = {
        **({"match": patterns} if patterns else {})
    }
    response = client.request("GET", "/api/certs", params=params)
    
    result = Result(response, format)
    return result.render_and_exit(columns)
    

@cert_app.command(help="Update local expired certificates in place by downloading new certificates from the server")
def update_in_place(
    ctx: typer.Context,
    timeout: int = Opt.timeout(10),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    dest_dir: str = typer.Option(
        ..., "--dest-dir", "-d",
        help="Directory containing certificate files to check and update"
    ),
    post_hook: str = typer.Option(
        None, "--post-hook",
        help="Executable to run after successful update of any locally expired certificate"
    ),
    nagios_server: str = typer.Option(
        None, "--nagios-server",
        help=""  
    ),
    nagios_hostname: str = typer.Option(
        None, "--nagios-host",
        help=""
    ),
    nagios_service: str = typer.Option(
        None, '--nagios-service',
        help=""
    )
) -> None: 
    settings = load_settings(ctx)
    nagios = Nagios.from_options(nagios_server, nagios_hostname, nagios_service, format)
    certs_dir = Path(dest_dir)
    
    if not certs_dir.exists():
        raise typer.BadParameter(f"Directory provided by -d/--dest-dir does not exist: {certs_dir}")
    if not certs_dir.is_dir():
        raise typer.BadParameter(f"Value provided by -d/--dest-dir is not a directory: {certs_dir}")
    
    params = {
        **({"match": patterns} if patterns else {})
    }
    
    client = Client.init(settings.api_url, settings.token, timeout=timeout, format=format, nagios=nagios)
    response = client.request("GET", "/api/certs", params=params)
    result = Result(response, format)
    
    if not response.ok:
        if nagios:
            nagios.send_passive(f"{ExitCode.CRITICAL.name}: Failed to fetch certificates, response: {result.data}", ExitCode.CRITICAL)
        result.render_and_exit()
    
    any_updated = False
    updated_certs: list[str] = []
    results: list[dict[str, Any]] = []

    for cert in result.data:
        cert_id = cert.get("id")
        
        try:
            pem_filename = dict(cert.get("custom_attrs"))["pem_filename"]
        except (TypeError, KeyError):
            results.append({ # TODO - Change to some class
                "cert_id": cert_id,
                "code": ExitCode.UNKNOWN,
                "result": "skipped: missing_pem_filename",
                "expire_date": None,
                "local_path": None,
                "updated": False,
            })
            continue
        if not pem_filename.endswith(".pem"): # TODO - Maybe add some additional validation if someone will provide badbad filename?
            pem_filename.append(f"{pem_filename}.pem")
        
        certificate = cert.get("certificate")
        if not certificate:
            results.append({
                "cert_id": cert_id,
                "code": ExitCode.CRITICAL,
                "result": "skipped: missing_certificate",
                "expire_date": None,
                "local_path": str(certs_dir / pem_filename),
                "updated": False,
            })
            continue
        
        expire_date_str = cert.get("expire_date")
        if not expire_date_str:
            results.append({
                "cert_id": cert_id,
                "code": ExitCode.CRITICAL,
                "result": "skipped: missing_expire_date",
                "expire_date": None,
                "local_path": str(certs_dir / pem_filename),
                "updated": False
            })
            continue
        try:
            expire_date = datetime.strptime(expire_date_str, "%Y-%m-%d %H:%M").replace(tzinfo=timezone.utc)
        except ValueError:
            results.append({
                "cert_id": cert_id,
                "code": ExitCode.CRITICAL,
                "result": "skipped: invalid_expire_date",
                "expire_date": expire_date_str,
                "local_path": str(certs_dir / pem_filename),
                "updated": False,
            })
            continue
        
        
        
        local_pem_file: Path | None = None
        for f in certs_dir.iterdir():
            if f.is_file() and f.name == pem_filename:
                local_pem_file = f
        
        chain = cert.get("chain")
        private_key = cert.get("private_key")
        pem_parts = [part.strip() for part in [certificate, chain, private_key] if part]
        pem_bundle = "\n".join(pem_parts) + "\n"
        
        if local_pem_file is None: # Add new certificate
            local_pem_file = certs_dir / str(pem_filename)
            local_pem_file.write_text(pem_bundle, encoding="UTF-8")
            updated_certs.append(str(local_pem_file))
            any_updated = True
            results.append({ 
                "cert_id": cert_id,
                "code": ExitCode.OK,
                "result": "created",
                "expire_date": expire_date_str,
                "local_path": str(local_pem_file),
                "updated": True
            })
            continue
        else:
            try:
                local_expire_date = get_cert_expire_date(local_pem_file)
            except Exception as e:
                results.append({
                    "cert_id": cert_id,
                    "code": ExitCode.WARNING,
                    "result": f"skipped: cannot retrieve local expire_date {e}",
                    "expire_date": expire_date_str,
                    "local_path": str(local_pem_file),
                    "updated": False
                })
                continue
            
            if expire_date <= local_expire_date: # Local certificate is newer
                results.append({
                    "cert_id": cert_id,
                    "code": ExitCode.OK,
                    "result": "up_to_date",
                    "expire_date": expire_date_str,
                    "local_path": str(local_pem_file),
                    "updated": False
                })
                continue
            
            local_pem_file.write_text(pem_bundle, encoding="utf-8") # Update cert
            updated_certs.append(str(local_pem_file))
            any_updated = True
            results.append({
                "cert_id": cert_id,
                "status": "updated",
                "code": ExitCode.OK,
                "expire_date": expire_date_str,
                "local_path": str(local_pem_file),
                "updated": True
            })
    
    if any_updated and post_hook:
        result = run_cmd(post_hook, shell=True)
        if result.returncode != 0:
            data = {
                "msg": "Failed to run post-hook after successful local certificates update",
                "error": result.stderr,
                "return_code": result.returncode,
                "cmd": post_hook
            }
            result = Result(data, ExitCode.CRITICAL)
            if nagios:
                nagios.send_passive(f"{ExitCode.CRITICAL.name}: {data['msg']}, error: {data['error']}", ExitCode.CRITICAL)
            return result.render_and_exit()
    
    result = Result(results, format)
    if nagios:
        exit_code = ExitCode.OK # TODO - Check if results contains any bad status
        nagios.send_passive(f"{exit_code.name}: TODO", exit_code)
    
    # Todo - Raises error, because provided "status" contains non-serializable ExitCode objects
    return result.render_and_exit(columns)

# Helper functions

def load_settings(ctx: typer.Context) -> Settings:
    settings = ctx.obj
    if not isinstance(settings, Settings):
        raise typer.Exit(code=2)
    
    file_settings: dict[str, str] = {}
    if SETTINGS_FILE.exists():
        file_mode = SETTINGS_FILE.stat().st_mode & 0o777
        if file_mode != 0o600:
            raise typer.BadParameter(
                f"Invalid permissions for {SETTINGS_FILE}: expected 'rw-------' (600), got {file_mode:o}, use command:\nchmod 600 {SETTINGS_FILE}"
            )

        for line in read_file(SETTINGS_FILE).splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if "=" not in line:
                continue

            key, value = line.split("=", 1)
            file_settings[key.strip().upper()] = value.strip()

    if not settings.api_url:
        settings.api_url = file_settings.get("API_URL")
    if not settings.token:
        settings.token = file_settings.get("TOKEN")

    if not settings.api_url:
        raise typer.BadParameter(
            f"Provide --api-url, set {ENV_VAR_API_URL} environment variable, or add API_URL=<value> in {SETTINGS_FILE}"
        )
    return settings


def read_file(file_path: Path) -> str:
    try:
        return file_path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return file_path.read_text(encoding="ascii", errors="ignore")


def get_cert_expire_date(cert_file_path: Path) -> datetime:
    pem_content = read_file(cert_file_path)
    begin_marker = "-----BEGIN CERTIFICATE-----"
    end_marker = "-----END CERTIFICATE-----"
    cert_start = pem_content.find(begin_marker)
    cert_end = pem_content.find(end_marker, cert_start)
    if cert_start == -1 or cert_end == -1:
        raise ValueError(f"File '{cert_file_path}' does not contain a valid PEM certificate block")
    
    cert_end += len(end_marker)
    cert_pem = pem_content[cert_start:cert_end].encode("utf-8")
    
    try:
        cert = x509.load_pem_x509_certificate(cert_pem)
    except ValueError as e:
        raise ValueError(f"Cannot parse certificate from file '{cert_file_path}': {e}")
    
    expire_date_utc = getattr(cert, "not_valid_after_utc", None)
    if expire_date_utc is not None:
        return expire_date_utc.astimezone(timezone.utc)
    
    expire_date = cert.not_valid_after
    if expire_date.tzinfo is None:
        expire_date = expire_date.replace(tzinfo=timezone.utc)
    return expire_date.astimezone(timezone.utc)


@dataclass
class Result:
    data: dict | list[dict]
    exit_code: ExitCode
    format: Format
    
    def __init__(
        self, 
        result: requests.Response | dict | list[dict],
        format: str,
        exit_code: ExitCode = None
    ) -> None:
        if isinstance(result, requests.Response):
            self.data = self._parse_response(result)
            self.exit_code = exit_code or (ExitCode.OK if result.ok else ExitCode.CRITICAL)
        else:
            self.data = result
            self.exit_code = exit_code or ExitCode.OK
        try:
            self.format = Format(format)
        except ValueError:
            raise typer.BadParameter(f"Unknown format: {format}, must be one of: {(', ').join(Format.values())}")

    
    def _parse_response(self, response: requests.Response) -> dict | list[dict]:
        try:
            payload = response.json()
        except ValueError:
            return {"message": response.text}

        if not isinstance(payload, dict):
            return payload

        payload.pop("timestamp", None)
        if response.ok:
            payload.pop("path", None)
            payload.pop("code", None)
            payload = payload['data']
            
        return payload

    
    def _filter_data(self, columns: list[str] | None = None) -> Any:
        if not columns:
            return self.data

        available_columns: set[str] = set()
        
        if isinstance(self.data, dict):
            available_columns = set(self.data.keys())
        elif isinstance(self.data, list):
            for row in self.data:
                if isinstance(row, dict):
                    available_columns.update(row.keys())

        missing_columns = [col for col in columns if col not in available_columns]
        if missing_columns:
            possible_columns = ", ".join(sorted(available_columns)) if available_columns else "<none>"
            missing = ", ".join(missing_columns)
            raise typer.BadParameter(f"Unknown column(s): {missing}, available choices: {possible_columns}")

        if isinstance(self.data, list):
            filtered_data = []
            for row in self.data:
                if isinstance(row, dict):
                    filtered_data.append({col: row.get(col) for col in columns})
                else:
                    filtered_data.append(row)
            return filtered_data

        if isinstance(self.data, dict):
            return {col: self.data.get(col) for col in columns}

        return self.data


    def render_and_exit(self, columns: list[str] | None = None) -> NoReturn:
        def _convert_val_as_str(val: Any) -> str:
            if isinstance(val, (dict, list)):
                return json.dumps(val, ensure_ascii=False)
            return str(val)

        def _render_field(key: Any, val: Any, key_width: int) -> str:
            key_as_str = str(key)
            val_as_str = _convert_val_as_str(val)
            return f"{key_as_str:<{key_width}} = {val_as_str}"
        
        def _render_table_cell(value) -> str:
            def format_kv_block(obj: dict, indent: str = "  ") -> str:
                key_width = max((len(str(k)) for k in obj.keys()), default=0)
                lines = []
                for k in sorted(obj.keys(), key=lambda x: str(x)):
                    v = obj[k]
                    if isinstance(v, (dict, list)):
                        v_str = json.dumps(v, ensure_ascii=False)
                    else:
                        v_str = str(v)
                    lines.append(f"{indent}{str(k):<{key_width}} = {v_str}")
                return "\n".join(lines)
            
            if value is None:
                return "-"

            if isinstance(value, dict):
                if not value:
                    return "{}"
                return format_kv_block(value, indent="")

            if isinstance(value, list):
                if not value:
                    return "-"

                if all(isinstance(x, dict) for x in value):
                    blocks = []
                    for i, item in enumerate(value, start=1):
                        header = f"• #{i}"
                        blocks.append(header)
                        blocks.append(format_kv_block(item, indent="  "))
                    return "\n".join(blocks)

                lines = []
                for item in value:
                    if isinstance(item, dict):
                        lines.append("•")
                        lines.append(format_kv_block(item, indent="  "))
                    elif isinstance(item, list):
                        lines.append("• " + json.dumps(item, ensure_ascii=False))
                    else:
                        lines.append(f"• {item}")
                return "\n".join(lines)
            return str(value)

        def _print(value: Any = "") -> None:
            if self.exit_code.value == 0:
                console.print(value)
                return
            if isinstance(value, str):
                console.print(value, style="red", markup=False, highlight=False)
                return
            console.print(value, style="red", highlight=False)
        
        data = self._filter_data(columns) if self.exit_code.value == 0 else self.data
        
        if self.format == Format.JSON:
            _print(json.dumps(data, indent=2, ensure_ascii=False))
        elif self.format == Format.VALUE:
            if isinstance(data, dict):
                for val in data.values():
                    _print(_convert_val_as_str(val))
            elif isinstance(data, list):
                if all(isinstance(item, dict) for item in data):
                    for item in data:
                        for val in item.values():
                            _print(_convert_val_as_str(val))
                        if item != data[-1]: # Do not print on last iteration
                            _print()
                else:
                    for item in data:
                        _print(item)
        elif self.format == Format.KEY_VALUE:
            if isinstance(data, dict):
                key_width = max((len(str(key)) for key in data.keys()), default=0)
                for key, val in data.items():
                    _print(_render_field(key, val, key_width))
                    
            elif isinstance(data, list):
                if all(isinstance(item, dict) for item in data):
                    key_width = max((len(str(key)) for item in data for key in item.keys()), default=0)
                    
                    for item in data:
                        for key, val in item.items():
                            _print(_render_field(key, val, key_width))
                        if item != data[-1]: # Do not print on last iteration
                            _print()
                else:
                    for item in data:
                        _print(item)
            else:
                _print(data)
        elif self.format == Format.TABLE:
            rows = data if isinstance(data, list) else [data]
            if rows:
                table = Table(show_header=True, header_style="bold", expand=True, show_lines=True, box=box.ROUNDED)

                cols = list(rows[0].keys())
                for c in cols:
                    table.add_column(str(c), overflow="fold") # fold helps if mucho text

                for row in rows:
                    table.add_row(*[_render_table_cell(row.get(c, "")) for c in cols])
                _print(table)

        raise typer.Exit(code=self.exit_code.value)


def run_cmd(
    args: Sequence[str] | str,
    *,
    shell: bool = True,
    timeout: Optional[int] = 15
) -> subprocess.CompletedProcess[str]:
    cmd: str | list[str]
    if shell:
        if isinstance(args, str):
            cmd = args
        else:
            cmd = " ".join(shlex.quote(str(a)) for a in args)
    else:
        if isinstance(args, str):
            cmd = shlex.split(args)
        else:
            cmd = [str(a) for a in args]
    
    result = subprocess.run(
        cmd,
        stdin=subprocess.DEVNULL, 
        stderr=subprocess.PIPE, 
        stdout=subprocess.PIPE, 
        text=True,
        shell=shell,
        executable="/bin/bash",
        timeout=timeout
    )
    return result


if __name__ == "__main__":
    app()
