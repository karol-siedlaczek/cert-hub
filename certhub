#!/usr/bin/env python3

# Karol Siedlaczek 2026

import os
import json
import shlex
import typer
import hmac
import hashlib
import base64
import sys
import binascii
import subprocess
from datetime import datetime, timezone
from enum import Enum
from fnmatch import fnmatch
from getpass import getpass
from pathlib import Path
from rich.console import Console
from rich.table import Table, box
from dataclasses import dataclass
from typing import Any, Optional, Dict, Sequence
import requests
from cryptography import x509

ENV_VAR_API_URL = "CERTHUB_API_URL"
ENV_VAR_TOKEN = "CERTHUB_TOKEN"
SETTINGS_FILE = Path("~/.certhub").expanduser()


class CertUpdateException(Exception):
    pass


class Nagios(Enum):
    NSCA_CMD = "/usr/sbin/send_nsca"
    OK = 0
    WARNING = 1
    CRITICAL = 2
    UNKNOWN = 3
    
    @staticmethod
    def send_passive(
        nagios_server: str, 
        nagios_host: str, 
        nagios_check: str, 
        status: "Nagios",
        msg: str
    ) -> str:
        args = [
            "echo",
            "-e",
            f"{nagios_host}\t{nagios_check}\t{status.value}\t{msg}",
            "|",
            Nagios.NSCA_CMD.value,
            "-H",
            nagios_server
        ]
        result = run_cmd(args, shell=True)
        if result.returncode != 0:
            raise typer.BadParameter(f"Failed to send nagios passive, command: {args}, error: {result.stderr}")
        return result.stdout


class Format(Enum):
    TABLE = "table"
    JSON = "json"
    KEY_VALUE = "kv"
    VALUE = "value"
    
    @classmethod
    def values(cls) -> list[str]:
        return [item.value for item in cls]
    
    @classmethod
    def default(cls) -> str:
        return Format.TABLE.value


class Opt:
    @staticmethod
    def timeout(default: int = 10) -> Any:
        return typer.Option(
            default, "--timeout", "-t",
            help="API request timeout in seconds",
        )

    @staticmethod
    def format(default: str | None = None) -> Any:
        return typer.Option(
            default or Format.default(), "--format", "-f",
            help=f"Output format: {", ".join(Format.values())}",
        )

    @staticmethod
    def columns() -> Any:
        return typer.Option(
            None, "-c", "--column",
            help="Specify the column(s) to include, can be repeated to show multiple columns",
        )

    @staticmethod
    def patterns() -> Any:
        return typer.Option(
            None, "--pattern", "-p",
            help="Certificate pattern, can be specified multiple times. Defaults to all certificates allowed for the current identity",
        )

    @staticmethod
    def force(help_text: str) -> Any:
        return typer.Option(
            None, "--force",
            help=help_text,
        )


@dataclass
class Settings:
    api_url: str | None
    token: str | None


app = typer.Typer(
    add_completion=True, 
    help="CLI for managing certificates in Cert Hub"
)
cert_app = typer.Typer(help=f"Certificate commands, use '{sys.argv[0]} cert --help' for details")
token_app = typer.Typer(help=f"Token commands, add '{sys.argv[0]} token --help' for details")
app.add_typer(cert_app, name="cert")
app.add_typer(token_app, name="token")
console = Console()


@app.callback()
def main(
    ctx: typer.Context,
    api_url: str = typer.Option(
        "http://localhost:8080", "--base-url",
        envvar=ENV_VAR_API_URL,
        help=f"API base URL. You can set environment or set API_URL=<value> in {SETTINGS_FILE}",
    ),
    token: str = typer.Option(
        None, "--token",
        envvar=ENV_VAR_TOKEN,
        help=f"Bearer token. You can set environment or set TOKEN=<value> in {SETTINGS_FILE}",
    )
) -> None:
    ctx.obj = Settings(api_url=api_url, token=token)

# Client

@dataclass(frozen=True)
class Client():
    base_url: str
    session: requests.Session
    timeout: int
    
    @classmethod
    def init(cls, base_url: str, token: Optional[str] = None, *, timeout: int) -> "Client":
        base_url = base_url.rstrip("/")
        session = requests.Session()
        
        if token:
            session.headers.update({"Authorization": f"Bearer {token}"})

        session.headers.update({"Accept": "application/json"})
        
        try:
            session.request("GET", f"{base_url}/ping", timeout=10)
        except requests.RequestException as e:
            typer.secho(
                f"Error connecting to API server: {e}",
                fg=typer.colors.RED,
                err=True,
            )
            raise typer.Exit(code=1)
        return cls(base_url, session, timeout or 10)
    
    
    def request(
        self, 
        method: str, 
        path: str, 
        *, 
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> requests.Response:
        url = f"{self.base_url}{path}"
        
        response = self.session.request(
            method=method.upper(),
            url=url,
            params=params,
            json=json_body,
            timeout=self.timeout
        )
        
        return response

# Commands    
    
@app.command(help="Versions and author")
def version(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/version")
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)


@token_app.command(help="Permitted certificates for current identity")
def scope(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/scope")
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)
    
    
@token_app.command(help="Current identity information (e.g. allowed CIDRs, permissions)")
def identity(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/identity")
    payload = parse_response(response)
    
    if payload.get("permissions"):
        payload["permissions"] = [f"{p['scope']}:{p['action']}" for p in payload["permissions"]]
    
    render(payload, format, response.ok, columns)


@token_app.command(help="Generate TOKEN_<ID>_HMAC value for server configuration") 
def gen_hmac(
    hmac_key_b64: str = typer.Option(
        None, "--hmac-key-b64",
        help="Base64-encoded HMAC key, min length is at least 32 bytes (must match server HMAC_KEY_B64). If not provided, you will be prompted (Recommended)",
    ),
    token_id: str = typer.Option(
        None, "--id", "-i",
        help="Identity ID used as <id> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted",
    ),
    token_value: str = typer.Option(
        None, "--token", "-t",
        help="Raw token value used as <token> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted (Recommended)",
    )
) -> None:
    if token_id is None:
        token_id = input("Token ID: ").strip()
    if hmac_key_b64 is None:
        hmac_key_b64 = getpass("HMAC key (base64): ").strip()
    if token_value is None:
        token_value_1 = getpass("Token value: ").strip()
        token_value_2 = getpass("Confirm token value: ").strip()
        
        if token_value_1 != token_value_2:
            raise typer.BadParameter("Token values do not match")
        
        if not token_value_1:
            raise typer.BadParameter("Token value cannot be empty")
        
        token_value = token_value_1
        
    try:
        hmac_key = base64.b64decode(hmac_key_b64, validate=True)
    except binascii.Error:
        raise typer.BadParameter(
            "Invalid HMAC key: not valid base64.\n"
            "Generate a new one with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )
    
    if len(hmac_key) < 32:
        raise typer.BadParameter(
            "Invalid HMAC key: decoded key must be at least 32 bytes.\n"
            "Generate a secure key with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )

    token = str(token_value).encode()
    hmac_key = hmac.new(hmac_key, token, hashlib.sha256)
    
    typer.secho("\nSuccess!\n", fg=typer.colors.GREEN)
    print("Add the following environment variable to the server:")
    print(f"TOKEN_{token_id.upper()}_HMAC={hmac_key.hexdigest()}\n")


@cert_app.command(help="Statuses for all certificates")
def health(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    exclude_ok: bool = typer.Option(
        None, "--exclude-ok", 
        help="Hide certificates with OK status"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if exclude_ok:
        params["exclude_ok"] = "true"
    if patterns:
        params["match"] = patterns
        
    response = client.request("GET", "/api/health", params=params)
    payload = parse_response(response) 
    
    if payload.get("certs"):
        payload = payload["certs"]
    
    render(payload, format, response.ok, columns)
    

@cert_app.command(help="Issue new certificates for the current identity or selected pattern")
def issue(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    force: bool = Opt.force("Force reissue of certificate even if it already exists")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if force:
        params["force"] = "true"
    if patterns:
        params["match"] = patterns
        
    response = client.request("POST", "/api/certs/issue", params=params)
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)


@cert_app.command(help="Renew existing certificates for the current identity or selected pattern")
def renew(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    force: bool = Opt.force("Force certificate renew even if it does not expire")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if force:
        params["force"] = "true"
    if patterns:
        params["match"] = patterns
        
    response = client.request("POST", "/api/certs/renew", params=params)
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)
    

@cert_app.command(help="List certificates available for the current identity or selected pattern")
def get(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if patterns:
        params["match"] = patterns
    
    response = client.request("GET", "/api/certs", params=params)
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)
    

@cert_app.command(help="Update local expired certificates in place by downloading new certificates from the server")
def update_in_place(
    ctx: typer.Context,
    timeout: int = Opt.timeout(10),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns(),
    dest_dir: str = typer.Option(
        ..., "--dest-dir", "-d",
        help="Directory containing certificate files to check and update"
    ),
    post_hook: str = typer.Option(
        None, "--post-hook",
        help="Executable to run after successful update of any locally expired certificate"
    ),
    nagios_server: str = typer.Option(
        None, "--nagios-server",
        help=""  
    ),
    nagios_host: str = typer.Option(
        None, "--nagios-host",
        help=""
    ),
    nagios_check: str = typer.Option(
        None, '--nagios-check',
        help=""
    )
) -> None: 
    settings = load_settings(ctx)
    has_any_nagios_arg = any([nagios_server, nagios_host, nagios_check])
    is_send_nagios_passive = all([nagios_server, nagios_host, nagios_check])
    
    try:
        if has_any_nagios_arg:
            if not is_send_nagios_passive:
                raise CertUpdateException(
                    "To send passive to Nagios with command result options --nagios-server, --nagios-host and --nagios-check must be provided together"
                )
            send_nsca_path = Path(Nagios.NSCA_CMD.value)
            if not (send_nsca_path.exists() and os.access(send_nsca_path, os.X_OK)):
                raise CertUpdateException(f"Cannot send passive to Nagios, {Nagios.NSCA_CMD.value} not found or not executable")
        
        certs_dir = Path(dest_dir)
        
        if not certs_dir.exists():
            raise CertUpdateException(f"Directory provided by -d/--dest-dir does not exist: {certs_dir}")
        if not certs_dir.is_dir():
            raise CertUpdateException(f"Value provided -d/--dest-dir is not a directory: {certs_dir}")
        
        params = {}
        if patterns:
            params["match"] = patterns
        
        client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
        response = client.request("GET", "/api/certs", params=params)
        payload = parse_response(response)
        
        if not response.ok:
            render(payload, format, response.ok, columns)
            raise CertUpdateException(f"Failed to fetch certificates: {payload}")
    except CertUpdateException as e:
        if is_send_nagios_passive:
            Nagios.send_passive(nagios_server, nagios_host, nagios_check, Nagios.CRITICAL, f"CRITICAL: {str(e)}")
        raise typer.BadParameter(e)
    
    any_updated = False
    cert_date_format = "%Y-%m-%d %H:%M"
    updated_files: list[str] = []
    results: list[dict[str, Any]] = []

    for cert in payload:
        cert_id = cert.get("id", "<unknown>")
        expire_date_str = cert.get("expire_date")
        if not expire_date_str:
            results.append({
                "cert_id": cert_id,
                "status": "skipped: missing_expire_date",
                "expire_date": None,
                "local_path": None,
                "updated": False,
            })
            continue
        
        try:
            api_expire_date = datetime.strptime(expire_date_str, cert_date_format).replace(tzinfo=timezone.utc)
        except ValueError:
            results.append({
                "cert_id": cert_id,
                "status": "skipped: invalid_expire_date",
                "expire_date": expire_date_str,
                "local_path": None,
                "updated": False,
            })
            continue
        
        try:
            pem_filename = dict(cert.get("custom_attrs"))["pem_filename"]
        except (TypeError, KeyError):
            results.append({
                "cert_id": cert_id,
                "status": "skipped: missing_pem_filename",
                "expire_date": expire_date_str,
                "local_path": None,
                "updated": False,
            })
            continue
        
        certificate = cert.get("certificate")
        if not certificate:
            default_path = certs_dir / (pem_filename if pem_filename.endswith(".pem") else f"{pem_filename}.pem")
            results.append({
                "cert_id": cert_id,
                "status": "skipped: missing_certificate",
                "expire_date": expire_date_str,
                "local_path": str(default_path),
                "updated": False,
            })
            continue
        
        chain = cert.get("chain")
        private_key = cert.get("private_key")
        pem_parts = [part.strip() for part in [certificate, chain, private_key] if part]
        pem_bundle = "\n".join(pem_parts) + "\n"
        
        candidate_names = [pem_filename]
        if not pem_filename.endswith(".pem"):
            candidate_names.append(f"{pem_filename}.pem")
        
        matching_paths: list[Path] = []
        for cert_file_path in certs_dir.iterdir():
            if not cert_file_path.is_file():
                continue
            if any(fnmatch(cert_file_path.name, candidate) for candidate in candidate_names):
                matching_paths.append(cert_file_path)

        if not matching_paths:
            if any(ch in pem_filename for ch in {"*", "?", "["}):
                new_filename = f"{cert_id}.pem"
            else:
                new_filename = pem_filename if pem_filename.endswith(".pem") else f"{pem_filename}.pem"
            new_path = certs_dir / new_filename
            new_path.write_text(pem_bundle, encoding="utf-8")
            updated_files.append(str(new_path))
            any_updated = True
            results.append({
                "cert_id": cert_id,
                "status": "created",
                "expire_date": expire_date_str,
                "local_path": str(new_path),
                "updated": True,
            })
            continue
        
        for cert_file_path in matching_paths:
            local_expire_date = get_cert_expire_date(cert_file_path)
            if not local_expire_date:
                results.append({
                    "cert_id": cert_id,
                    "status": "skipped: local_expire_not_found",
                    "expire_date": expire_date_str,
                    "local_path": str(cert_file_path),
                    "updated": False,
                })
                continue
            if api_expire_date <= local_expire_date:
                results.append({
                    "cert_id": cert_id,
                    "status": "up_to_date",
                    "expire_date": expire_date_str,
                    "local_path": str(cert_file_path),
                    "updated": False,
                })
                continue
            
            cert_file_path.write_text(pem_bundle, encoding="utf-8")
            updated_files.append(str(cert_file_path))
            any_updated = True
            results.append({
                "cert_id": cert_id,
                "status": "updated",
                "expire_date": expire_date_str,
                "local_path": str(cert_file_path),
                "updated": True,
            })
    
        
    if any_updated and post_hook:
        result = run_cmd(post_hook, shell=True)
        if result.returncode != 0:
            raise typer.BadParameter(f"Failed to run post-hook '{post_hook}', error: {result.stderr}")
    
    render(results, format, True, columns)
    if is_send_nagios_passive:
        msg = f"OK: update-in-place completed, updated={len(updated_files)}"
        Nagios.send_passive(nagios_server, nagios_host, nagios_check, Nagios.OK, msg)


# Helper functions

def load_settings(ctx: typer.Context) -> Settings:
    settings = ctx.obj
    if not isinstance(settings, Settings):
        raise typer.Exit(code=2)
    
    file_settings: dict[str, str] = {}
    if SETTINGS_FILE.exists():
        file_mode = SETTINGS_FILE.stat().st_mode & 0o777
        if file_mode != 0o600:
            raise typer.BadParameter(
                f"Invalid permissions for {SETTINGS_FILE}: expected 'rw-------' (600), got {file_mode:o}, use command:\nchmod 600 {SETTINGS_FILE}"
            )

        for line in read_file(SETTINGS_FILE).splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if "=" not in line:
                continue

            key, value = line.split("=", 1)
            file_settings[key.strip().upper()] = value.strip()

    if not settings.api_url:
        settings.api_url = file_settings.get("API_URL")
    if not settings.token:
        settings.token = file_settings.get("TOKEN")

    if not settings.api_url:
        raise typer.BadParameter(
            f"Provide --api-url, set {ENV_VAR_API_URL} environment variable, or add API_URL=<value> in {SETTINGS_FILE}"
        )
    return settings


def parse_response(response: requests.Response) -> dict | list[dict]:
    try:
        payload = response.json()
    except ValueError:
        return {"message": response.text}

    if not isinstance(payload, dict):
        return payload

    payload.pop("timestamp", None)
    if response.ok:
        payload.pop("path", None)
        payload.pop("code", None)
        payload = payload['data']
        
    return payload


def read_file(file_path: Path) -> str:
    try:
        return file_path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return file_path.read_text(encoding="ascii", errors="ignore")


def get_cert_expire_date(cert_file_path: Path) -> datetime | None:
    pem_content = read_file(cert_file_path)
    begin_marker = "-----BEGIN CERTIFICATE-----"
    end_marker = "-----END CERTIFICATE-----"
    cert_start = pem_content.find(begin_marker)
    cert_end = pem_content.find(end_marker, cert_start)
    if cert_start == -1 or cert_end == -1:
        return None
    
    cert_end += len(end_marker)
    cert_pem = pem_content[cert_start:cert_end].encode("utf-8")
    
    try:
        cert = x509.load_pem_x509_certificate(cert_pem)
    except ValueError as e:
        raise CertUpdateException(f"Cannot parse local certificate '{cert_file_path}': {e}")
    
    expire_date_utc = getattr(cert, "not_valid_after_utc", None)
    if expire_date_utc is not None:
        return expire_date_utc.astimezone(timezone.utc)
    
    expire_date = cert.not_valid_after
    if expire_date.tzinfo is None:
        expire_date = expire_date.replace(tzinfo=timezone.utc)
    return expire_date.astimezone(timezone.utc)


def render_table_cell(value) -> str:
    def format_kv_block(obj: dict, indent: str = "  ") -> str:
        key_width = max((len(str(k)) for k in obj.keys()), default=0)
        lines = []
        for k in sorted(obj.keys(), key=lambda x: str(x)):
            v = obj[k]
            if isinstance(v, (dict, list)):
                v_str = json.dumps(v, ensure_ascii=False)
            else:
                v_str = str(v)
            lines.append(f"{indent}{str(k):<{key_width}} = {v_str}")
        return "\n".join(lines)
    
    if value is None:
        return "-"

    if isinstance(value, dict):
        if not value:
            return "{}"
        return format_kv_block(value, indent="")

    if isinstance(value, list):
        if not value:
            return "-"

        if all(isinstance(x, dict) for x in value):
            blocks = []
            for i, item in enumerate(value, start=1):
                header = f"• #{i}"
                blocks.append(header)
                blocks.append(format_kv_block(item, indent="  "))
            return "\n".join(blocks)

        lines = []
        for item in value:
            if isinstance(item, dict):
                lines.append("•")
                lines.append(format_kv_block(item, indent="  "))
            elif isinstance(item, list):
                lines.append("• " + json.dumps(item, ensure_ascii=False))
            else:
                lines.append(f"• {item}")
        return "\n".join(lines)

    return str(value)


def render(data, format: str, success: bool, columns: list[str] | None) -> None:
    def convert_val_as_str(val: Any) -> str:
        if isinstance(val, (dict, list)):
            return json.dumps(val, ensure_ascii=False)
        return str(val)

    def render_field(key: Any, val: Any, key_width: int) -> str:
        key_as_str = str(key)
        val_as_str = convert_val_as_str(val)
        return f"{key_as_str:<{key_width}} = {val_as_str}"

    def emit(value: Any = "") -> None:
        if success:
            console.print(value)
            return
        if isinstance(value, str):
            console.print(value, style="red", markup=False, highlight=False)
            return
        console.print(value, style="red", highlight=False)
                    
    if success:
        data = filter_data(data, columns)
    
    try:
        format = Format(format)
    except ValueError:
        raise typer.BadParameter(f"Unknown format: {format}, must be one of: {(', ').join(Format.values())}")
    
    if format == Format.JSON:
        emit(json.dumps(data, indent=2, ensure_ascii=False))
        return
    elif format == Format.VALUE:
        if isinstance(data, dict):
            for val in data.values():
                emit(convert_val_as_str(val))
        elif isinstance(data, list):
            if all(isinstance(item, dict) for item in data):
                for item in data:
                    for val in item.values():
                        emit(convert_val_as_str(val))
                    if item != data[-1]: # Do not print on last iteration
                        emit()
            else:
                for item in data:
                    emit(item)
        return
    elif format == Format.KEY_VALUE:
        if isinstance(data, dict):
            key_width = max((len(str(key)) for key in data.keys()), default=0)
            for key, val in data.items():
                emit(render_field(key, val, key_width))
        elif isinstance(data, list):
            if all(isinstance(item, dict) for item in data):
                key_width = max(
                    (len(str(key)) for item in data for key in item.keys()),
                    default=0,
                )
                for item in data:
                    for key, val in item.items():
                        emit(render_field(key, val, key_width))
                    if item != data[-1]: # Do not print on last iteration
                        emit()
            else:
                for item in data:
                    emit(item)
        else:
            emit(data)
        return
    elif format == Format.TABLE:
        rows = data if isinstance(data, list) else [data]
        if not rows:
            return

        table = Table(show_header=True, header_style="bold", expand=True, show_lines=True, box=box.ROUNDED)

        cols = list(rows[0].keys())
        for c in cols:
            table.add_column(str(c), overflow="fold")  # fold helps if mucho text

        for row in rows:
            table.add_row(*[render_table_cell(row.get(c, "")) for c in cols])

        emit(table)
        return


def filter_data(data: list | dict, columns: list[str] | None) -> Any:
    if not columns:
        return data

    available_columns: set[str] = set()
    
    if isinstance(data, dict):
        available_columns = set(data.keys())
    elif isinstance(data, list):
        for row in data:
            if isinstance(row, dict):
                available_columns.update(row.keys())

    missing_columns = [col for col in columns if col not in available_columns]
    if missing_columns:
        possible_columns = ", ".join(sorted(available_columns)) if available_columns else "<none>"
        missing = ", ".join(missing_columns)
        raise typer.BadParameter(f"Unknown column(s): {missing}, available choices: {possible_columns}")

    if isinstance(data, list):
        filtered_data = []
        for row in data:
            if isinstance(row, dict):
                filtered_data.append({col: row.get(col) for col in columns})
            else:
                filtered_data.append(row)
        return filtered_data

    if isinstance(data, dict):
        return {col: data.get(col) for col in columns}

    return data


def run_cmd(
    args: Sequence[str] | str,
    *,
    shell: bool = True,
    timeout: Optional[int] = 15
) -> subprocess.CompletedProcess[str]:
    cmd: str | list[str]
    if shell:
        if isinstance(args, str):
            cmd = args
        else:
            cmd = " ".join(shlex.quote(str(a)) for a in args)
    else:
        if isinstance(args, str):
            cmd = shlex.split(args)
        else:
            cmd = [str(a) for a in args]
    
    result = subprocess.run(
        cmd,
        stdin=subprocess.DEVNULL, 
        stderr=subprocess.PIPE, 
        stdout=subprocess.PIPE, 
        text=True,
        shell=shell,
        executable="/bin/bash",
        timeout=timeout
    )
    return result


if __name__ == "__main__":
    app()
