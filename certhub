#!/usr/bin/env python3

import json
import typer
import hmac
import hashlib
import base64
import sys
import binascii
from enum import Enum
from getpass import getpass
from pathlib import Path
from rich.console import Console
from rich.table import Table, box
from dataclasses import dataclass
from typing import Any, Optional, Dict
import requests

ENV_VAR_API_URL = "CERTHUB_API_URL"
ENV_VAR_TOKEN = "CERTHUB_TOKEN"
SETTINGS_FILE = Path("~/.certhub").expanduser()

class Format(Enum):
    TABLE = "table"
    JSON = "json"
    KEY_VALUE = "kv"
    VALUE = "value"
    
    @classmethod
    def values(cls) -> list[str]:
        return [item.value for item in cls]
    
    @classmethod
    def default(cls) -> str:
        return Format.TABLE.value


class Opt:
    @staticmethod
    def timeout(default: int = 10) -> Any:
        return typer.Option(
            default, "--timeout", "-t",
            help="API request timeout in seconds",
        )

    @staticmethod
    def format(default: str | None = None) -> Any:
        return typer.Option(
            default or Format.default(), "--format", "-f",
            help=f"Output format: {", ".join(Format.values())}",
        )

    @staticmethod
    def columns() -> Any:
        return typer.Option(
            None, "-c", "--column",
            help="Specify the column(s) to include, can be repeated to show multiple columns",
        )

    @staticmethod
    def patterns() -> Any:
        return typer.Option(
            None, "--pattern", "-p",
            help="Certificate pattern, can be specified multiple times. Defaults to all certificates allowed for the current identity",
        )

    @staticmethod
    def force(help_text: str) -> Any:
        return typer.Option(
            None, "--force",
            help=help_text,
        )


@dataclass
class Settings:
    api_url: str | None
    token: str | None


app = typer.Typer(
    add_completion=True, 
    help="CLI for managing certificates in Cert Hub"
)
cert_app = typer.Typer(help=f"Certificate commands, use '{sys.argv[0]} cert --help' for details")
token_app = typer.Typer(help=f"Token commands, add '{sys.argv[0]} token --help' for details")
app.add_typer(cert_app, name="cert")
app.add_typer(token_app, name="token")
console = Console()


@app.callback()
def main(
    ctx: typer.Context,
    api_url: str = typer.Option(
        "http://localhost:8080", "--base-url",
        envvar=ENV_VAR_API_URL,
        help=f"API base URL. You can set environment or set API_URL=<value> in {SETTINGS_FILE}",
    ),
    token: str = typer.Option(
        None, "--token",
        envvar=ENV_VAR_TOKEN,
        help=f"Bearer token. You can set environment or set TOKEN=<value> in {SETTINGS_FILE}",
    )
) -> None:
    ctx.obj = Settings(api_url=api_url, token=token)

# Client

@dataclass(frozen=True)
class Client():
    base_url: str
    session: requests.Session
    timeout: int
    
    @classmethod
    def init(cls, base_url: str, token: Optional[str] = None, *, timeout: int) -> "Client":
        base_url = base_url.rstrip("/")
        session = requests.Session()
        
        if token:
            session.headers.update({"Authorization": f"Bearer {token}"})

        session.headers.update({"Accept": "application/json"})
        
        try:
            session.request("GET", f"{base_url}/ping")
        except requests.RequestException as e:
            typer.secho(
                f"Error connecting to API server: {e}",
                fg=typer.colors.RED,
                err=True,
            )
            raise typer.Exit(code=1)

        return cls(base_url, session, timeout)
    
    
    def request(
        self, 
        method: str, 
        path: str, 
        *, 
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> requests.Response:
        url = f"{self.base_url}{path}"
        
        response = self.session.request(
            method=method.upper(),
            url=url,
            params=params,
            json=json_body,
            timeout=self.timeout
        )
        
        return response

# Commands    
    
@app.command(help="Versions and author")
def version(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/version")
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)


@token_app.command(help="Permitted certificates for current identity")
def scope(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/scope")
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)
    
    
@token_app.command(help="Current identity information (e.g. allowed CIDRs, permissions)")
def identity(
    ctx: typer.Context,
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/identity")
    payload = parse_response(response)
    
    if payload.get("permissions"):
        payload["permissions"] = [f"{p['scope']}:{p['action']}" for p in payload["permissions"]]
    
    render(payload, format, response.ok, columns)


@token_app.command(help="Generate TOKEN_<ID>_HMAC value for server configuration") 
def gen_hmac(
    hmac_key_b64: str = typer.Option(
        None, "--hmac-key-b64",
        help="Base64-encoded HMAC key, min length is at least 32 bytes (must match server HMAC_KEY_B64). If not provided, you will be prompted (Recommended)",
    ),
    token_id: str = typer.Option(
        None, "--id", "-i",
        help="Identity ID used as <id> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted",
    ),
    token_value: str = typer.Option(
        None, "--token", "-t",
        help="Raw token value used as <token> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted (Recommended)",
    )
) -> None:
    if token_id is None:
        token_id = input("Token ID: ").strip()
    if hmac_key_b64 is None:
        hmac_key_b64 = getpass("HMAC key (base64): ").strip()
    if token_value is None:
        token_value_1 = getpass("Token value: ").strip()
        token_value_2 = getpass("Confirm token value: ").strip()
        
        if token_value_1 != token_value_2:
            raise typer.BadParameter("Token values do not match")
        
        if not token_value_1:
            raise typer.BadParameter("Token value cannot be empty")
        
        token_value = token_value_1
        
    try:
        hmac_key = base64.b64decode(hmac_key_b64, validate=True)
    except binascii.Error:
        raise typer.BadParameter(
            "Invalid HMAC key: not valid base64.\n"
            "Generate a new one with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )
    
    if len(hmac_key) < 32:
        raise typer.BadParameter(
            "Invalid HMAC key: decoded key must be at least 32 bytes.\n"
            "Generate a secure key with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )

    token = str(token_value).encode()
    hmac_key = hmac.new(hmac_key, token, hashlib.sha256)
    
    typer.secho("\nSuccess!\n", fg=typer.colors.GREEN)
    print("Add the following environment variable to the server:")
    print(f"TOKEN_{token_id.upper()}_HMAC={hmac_key.hexdigest()}\n")


@cert_app.command(help="Statuses for all certificates")
def health(
    ctx: typer.Context,
    exclude_ok: bool = typer.Option(
        None, "--exclude-ok", 
        help="Hide certificates with OK status"
    ),
    timeout: int = Opt.timeout(),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if exclude_ok:
        params["exclude_ok"] = "true"
    if patterns:
        params["cert"] = patterns
        
    response = client.request("GET", "/api/health", params=params)
    payload = parse_response(response) 
    
    if payload.get("certs"):
        payload = payload["certs"]
    
    render(payload, format, response.ok, columns)
    

@cert_app.command(help="Issue new certificates for the current identity or selected pattern")
def issue(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    force: bool = Opt.force("Force reissue of certificate even if it already exists"),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if force:
        params["force"] = "true"
    if patterns:
        params["cert"] = patterns
        
    response = client.request("POST", "/api/certs/issue", params=params)
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)


@cert_app.command(help="Renew existing certificates for the current identity or selected pattern")
def renew(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    force: bool = Opt.force("Force certificate renew even if it does not expire"),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if force:
        params["force"] = "true"
    if patterns:
        params["cert"] = patterns
        
    response = client.request("POST", "/api/certs/renew", params=params)
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)
    

@cert_app.command(help="List certificates available for the current identity or selected pattern")
def get(
    ctx: typer.Context,
    timeout: int = Opt.timeout(360),
    format: str = Opt.format(),
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if patterns:
        params["cert"] = patterns
    
    response = client.request("GET", "/api/certs", params=params)
    payload = parse_response(response)
    
    render(payload, format, response.ok, columns)
    

@cert_app.command(help="Update local expired certificates in place by downloading new certificates from the server")
def update_in_place(
    ctx: typer.Context,
    dest_dir: str = typer.Option(
        ..., "--dest-dir", "-d",
        help="Directory containing certificate files to check and update"
    ),
    post_hook: str = typer.Option(
        None, "--post-hook",
        help="Executable to run after successful update of any locally expired certificate"
    ),
    format: str = Opt.format(), # TODO - needed?
    patterns: list[str] = Opt.patterns(),
    columns: list[str] = Opt.columns()
) -> None:
    settings = load_settings(ctx)
    # TODO HERE

# Helper functions

def load_settings(ctx: typer.Context) -> Settings:
    settings = ctx.obj
    if not isinstance(settings, Settings):
        raise typer.Exit(code=2)
    
    file_settings: dict[str, str] = {}
    if SETTINGS_FILE.exists():
        file_mode = SETTINGS_FILE.stat().st_mode & 0o777
        if file_mode != 0o600:
            raise typer.BadParameter(
                f"Invalid permissions for {SETTINGS_FILE}: expected 'rw-------' (600), got {file_mode:o}, use command:\nchmod 600 {SETTINGS_FILE}"
            )

        for line in read_file(SETTINGS_FILE).splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if "=" not in line:
                continue

            key, value = line.split("=", 1)
            file_settings[key.strip().upper()] = value.strip()

    if not settings.api_url:
        settings.api_url = file_settings.get("API_URL")
    if not settings.token:
        settings.token = file_settings.get("TOKEN")

    if not settings.api_url:
        raise typer.BadParameter(
            f"Provide --api-url, set {ENV_VAR_API_URL} environment variable, or add API_URL=<value> in {SETTINGS_FILE}"
        )
    return settings


def parse_response(response: requests.Response) -> dict:
    try:
        payload = response.json()
    except ValueError:
        return {"message": response.text}

    if not isinstance(payload, dict):
        return payload

    payload.pop("timestamp", None)
    if response.ok:
        payload.pop("path", None)
        payload.pop("code", None)
        payload = payload['data']
        
    return payload


def read_file(file_path: Path) -> str:
    try:
        return file_path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return file_path.read_text(encoding="ascii", errors="ignore")


def render_table_cell(value) -> str:
    def format_kv_block(obj: dict, indent: str = "  ") -> str:
        key_width = max((len(str(k)) for k in obj.keys()), default=0)
        lines = []
        for k in sorted(obj.keys(), key=lambda x: str(x)):
            v = obj[k]
            if isinstance(v, (dict, list)):
                v_str = json.dumps(v, ensure_ascii=False)
            else:
                v_str = str(v)
            lines.append(f"{indent}{str(k):<{key_width}} = {v_str}")
        return "\n".join(lines)
    
    if value is None:
        return "-"

    if isinstance(value, dict):
        if not value:
            return "{}"
        return format_kv_block(value, indent="")

    if isinstance(value, list):
        if not value:
            return "-"

        if all(isinstance(x, dict) for x in value):
            blocks = []
            for i, item in enumerate(value, start=1):
                header = f"• #{i}"
                blocks.append(header)
                blocks.append(format_kv_block(item, indent="  "))
            return "\n".join(blocks)

        lines = []
        for item in value:
            if isinstance(item, dict):
                lines.append("•")
                lines.append(format_kv_block(item, indent="  "))
            elif isinstance(item, list):
                lines.append("• " + json.dumps(item, ensure_ascii=False))
            else:
                lines.append(f"• {item}")
        return "\n".join(lines)

    return str(value)


def render(data, format: str, success: bool, columns: list[str] | None) -> None:
    def convert_val_as_str(val: Any) -> str:
        if isinstance(val, (dict, list)):
            return json.dumps(val, ensure_ascii=False)
        return str(val)

    def render_field(key: Any, val: Any, key_width: int) -> str:
        key_as_str = str(key)
        val_as_str = convert_val_as_str(val)
        return f"{key_as_str:<{key_width}} = {val_as_str}"

    def emit(value: Any = "") -> None:
        if success:
            console.print(value)
            return
        if isinstance(value, str):
            console.print(value, style="red", markup=False, highlight=False)
            return
        console.print(value, style="red", highlight=False)
                    
    if success:
        data = filter_data(data, columns)
    
    try:
        format = Format(format)
    except ValueError:
        raise typer.BadParameter(f"Unknown format: {format}, must be one of: {(', ').join(Format.values())}")
    
    if format == Format.JSON:
        emit(json.dumps(data, indent=2, ensure_ascii=False))
        return
    elif format == Format.VALUE:
        if isinstance(data, dict):
            for val in data.values():
                emit(convert_val_as_str(val))
        elif isinstance(data, list):
            if all(isinstance(item, dict) for item in data):
                for item in data:
                    for val in item.values():
                        emit(convert_val_as_str(val))
                    if item != data[-1]: # Do not print on last iteration
                        emit()
            else:
                for item in data:
                    emit(item)
        return
    elif format == Format.KEY_VALUE:
        if isinstance(data, dict):
            key_width = max((len(str(key)) for key in data.keys()), default=0)
            for key, val in data.items():
                emit(render_field(key, val, key_width))
        elif isinstance(data, list):
            if all(isinstance(item, dict) for item in data):
                key_width = max(
                    (len(str(key)) for item in data for key in item.keys()),
                    default=0,
                )
                for item in data:
                    for key, val in item.items():
                        emit(render_field(key, val, key_width))
                    if item != data[-1]: # Do not print on last iteration
                        emit()
            else:
                for item in data:
                    emit(item)
        else:
            emit(data)
        return
    elif format == Format.TABLE:
        rows = data if isinstance(data, list) else [data]
        if not rows:
            return

        table = Table(show_header=True, header_style="bold", expand=True, show_lines=True, box=box.ROUNDED)

        cols = list(rows[0].keys())
        for c in cols:
            table.add_column(str(c), overflow="fold")  # fold helps if mucho text

        for row in rows:
            table.add_row(*[render_table_cell(row.get(c, "")) for c in cols])

        emit(table)
        return


def filter_data(data: list | dict, columns: list[str] | None) -> Any:
    if not columns:
        return data

    available_columns: set[str] = set()
    
    if isinstance(data, dict):
        available_columns = set(data.keys())
    elif isinstance(data, list):
        for row in data:
            if isinstance(row, dict):
                available_columns.update(row.keys())

    missing_columns = [col for col in columns if col not in available_columns]
    if missing_columns:
        possible_columns = ", ".join(sorted(available_columns)) if available_columns else "<none>"
        missing = ", ".join(missing_columns)
        raise typer.BadParameter(f"Unknown column(s): {missing}, available choices: {possible_columns}")

    if isinstance(data, list):
        filtered_data = []
        for row in data:
            if isinstance(row, dict):
                filtered_data.append({col: row.get(col) for col in columns})
            else:
                filtered_data.append(row)
        return filtered_data

    if isinstance(data, dict):
        return {col: data.get(col) for col in columns}

    return data

if __name__ == "__main__":
    app()
