#!/usr/bin/env python3

import json
import typer
import hmac
import hashlib
import base64
import sys
import binascii
from getpass import getpass
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich import print as rprint
from dataclasses import dataclass
from typing import Any, Optional, Dict, List
import requests

ENV_VAR_API_URL = "CERTHUB_API_URL"
ENV_VAR_TOKEN = "CERTHUB_TOKEN"
SETTINGS_FILE = Path("~/.certhub").expanduser()

# App

app = typer.Typer(
    add_completion=True, 
    help="CLI for managing certificates in Cert Hub"
)
cert_app = typer.Typer(help=f"Certificate commands, use '{sys.argv[0]} cert --help' for details")
token_app = typer.Typer(help=f"Token commands, add '{sys.argv[0]} token --help' for details")
app.add_typer(cert_app, name="cert")
app.add_typer(token_app, name="token")
console = Console()

@dataclass
class Settings:
    api_url: str | None
    token: str | None
    

@app.callback()
def main(
    ctx: typer.Context,
    api_url: str = typer.Option(
        "http://localhost:8080",
        "--base-url",
        envvar=ENV_VAR_API_URL,
        help=f"API base URL. You can set environment or set API_URL=<value> in {SETTINGS_FILE}",
    ),
    token: str = typer.Option(
        None,
        "--token",
        envvar=ENV_VAR_TOKEN,
        help=f"Bearer token. You can set environment or set TOKEN=<value> in {SETTINGS_FILE}",
    )
) -> None:
    ctx.obj = Settings(api_url=api_url, token=token)

# Client

@dataclass(frozen=True)
class Client():
    base_url: str
    session: requests.Session
    timeout: int
    
    @classmethod
    def init(cls, base_url: str, token: Optional[str] = None, *, timeout: int) -> "Client":
        base_url = base_url.rstrip("/")
        session = requests.Session()
        
        if token:
            session.headers.update({"Authorization": f"Bearer {token}"})

        session.headers.update({"Accept": "application/json"})
        
        try:
            session.request("GET", f"{base_url}/ping")
        except requests.RequestException as e:
            typer.secho(
                f"Error connecting to API server: {e}",
                fg=typer.colors.RED,
                err=True,
            )
            raise typer.Exit(code=1)

        return cls(base_url, session, timeout)
    
    
    def request(
        self, 
        method: str, 
        path: str, 
        *, 
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> requests.Response:
        url = f"{self.base_url}{path}"
        
        response = self.session.request(
            method=method.upper(),
            url=url,
            params=params,
            json=json_body,
            timeout=self.timeout
        )
        
        return response

# Commands

@app.command(help="Statuses for all certificates")
def health(
    ctx: typer.Context,
    exclude_ok: bool = typer.Option(
        None, "--exclude-ok", 
        help="Hide certificates with OK status"
    ),
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if exclude_ok:
        params["exclude_ok"] = "true"
        
    response = client.request("GET", "/api/health", params=params)
    payload = parse_response(response) 
    
    if payload.get("certs"):
        payload = payload["certs"]
    
    render(payload, format)
    
    
@app.command(help="Versions and author")
def version(
    ctx: typer.Context,
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/version")
    payload = parse_response(response)
    
    render(payload, format)


@token_app.command(help="Permitted certificates for current identity")
def scope(
    ctx: typer.Context,
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/scope")
    payload = parse_response(response)
    
    render(payload, format)
    
    
@token_app.command(help="Current identity information (e.g. allowed CIDRs, permissions)")
def identity(
    ctx: typer.Context,
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text."
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/identity")
    payload = parse_response(response)
    
    if payload.get("permissions"):
        payload["permissions"] = [f"{p['scope']}:{p['action']}" for p in payload["permissions"]]
    
    render(payload, format)


@token_app.command(help="Generate TOKEN_<ID>_HMAC value for server configuration") 
def gen_hmac(
    hmac_key_b64: str = typer.Option(
        None, "--hmac-key-b64",
        help="Base64-encoded HMAC key, min length is at least 32 bytes (must match server HMAC_KEY_B64). If not provided, you will be prompted (Recommended)",
    ),
    token_id: str = typer.Option(
        None, "--id", "-i",
        help="Identity ID used as <id> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted",
    ),
    token_value: str = typer.Option(
        None, "--token", "-t",
        help="Raw token value used as <token> in 'Authorization: Bearer <id>.<token>'. If not provided, you will be prompted (Recommended)",
    )
) -> None:
    if token_id is None:
        token_id = input("Token ID: ").strip()
    if hmac_key_b64 is None:
        hmac_key_b64 = getpass("HMAC key (base64): ").strip()
    if token_value is None:
        token_value_1 = getpass("Token value: ").strip()
        token_value_2 = getpass("Confirm token value: ").strip()
        
        if token_value_1 != token_value_2:
            raise typer.BadParameter("Token values do not match")
        
        if not token_value_1:
            raise typer.BadParameter("Token value cannot be empty")
        
        token_value = token_value_1
        
    try:
        hmac_key = base64.b64decode(hmac_key_b64, validate=True)
    except binascii.Error:
        raise typer.BadParameter(
            "Invalid HMAC key: not valid base64.\n"
            "Generate a new one with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )
    
    if len(hmac_key) < 32:
        raise typer.BadParameter(
            "Invalid HMAC key: decoded key must be at least 32 bytes.\n"
            "Generate a secure key with:\n"
            "  openssl rand -base64 32\n\n"
            "NOTE !!!\nHMAC key must match server HMAC_KEY_B64"
        )

    token = str(token_value).encode()
    hmac_key = hmac.new(hmac_key, token, hashlib.sha256)
    
    typer.secho("\nSuccess!\n", fg=typer.colors.GREEN)
    print("Add the following environment variable to the server:")
    print(f"TOKEN_{token_id.upper()}_HMAC={hmac_key.hexdigest()}\n")


@cert_app.command(help="Issue new certificates for the current identity or selected certificate IDs")
def issue(
    ctx: typer.Context,
    timeout: int = typer.Option(
        360, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    ),
    cert_ids: list[str] = typer.Option(
        None, "--id", "-i",
        help="Certificate ID (supports patterns), can be specified multiple times. Defaults to all certificates allowed for the current identity"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)


@cert_app.command(help="Renew existing certificates for the current identity or selected certificate IDs")
def renew(
    ctx: typer.Context,
    timeout: int = typer.Option(
        360, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text."
    ),
    cert_ids: list[str] = typer.Option(
        None, "--id", "-i",
        help="Certificate ID (supports patterns), can be specified multiple times. Defaults to all certificates allowed for the current identity"
    )
) -> None:
    print(cert_ids)
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    

@cert_app.command(help="List certificates available for the current identity")
def list(
    ctx: typer.Context,
    timeout: int = typer.Option(
        360, "--timeout", "-t", 
        help="API request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    ),
    cert_ids: list[str] = typer.Option(
        None, "--id", "-i",
        help="Certificate ID (supports patterns), can be specified multiple times. Defaults to all certificates allowed for the current identity"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    response = client.request("GET", "/api/certs")
    payload = parse_response(response)
    
    render(payload, format)
    

@cert_app.command(help="Update local expired certificates in place by downloading new certificates from the server")
def update_in_place(
    ctx: typer.Context,
    dest_dir: str = typer.Option(
        ..., "--dest-dir", "-d",
        help="Directory containing certificate files to check and update"
    ),
    post_hook: str = typer.Option(
        None, "--post-hook",
        help="Executable to run after successful update of any locally expired certificate"
    )
) -> None:
    settings = load_settings(ctx)

# Helper functions

def load_settings(ctx: typer.Context) -> Settings:
    settings = ctx.obj
    if not isinstance(settings, Settings):
        raise typer.Exit(code=2)
    
    file_settings: dict[str, str] = {}
    if SETTINGS_FILE.exists():
        file_mode = SETTINGS_FILE.stat().st_mode & 0o777
        if file_mode != 0o600:
            raise typer.BadParameter(f"Invalid permissions for {SETTINGS_FILE}: expected 'rw-------' (600), got {file_mode:o}, use command:\nchmod 600 {SETTINGS_FILE}")

        for line in read_file(SETTINGS_FILE).splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if "=" not in line:
                continue

            key, value = line.split("=", 1)
            file_settings[key.strip().upper()] = value.strip()

    if not settings.api_url:
        settings.api_url = file_settings.get("API_URL")
    if not settings.token:
        settings.token = file_settings.get("TOKEN")

    if not settings.api_url:
        raise typer.BadParameter(
            f"Provide --api-url, set {ENV_VAR_API_URL} environment variable, or add API_URL=<value> in {SETTINGS_FILE}"
        )
    return settings


def parse_response(response: requests.Response) -> dict:
    try:
        payload = response.json()
    except ValueError:
        return {"message": response.text}

    if not isinstance(payload, dict):
        return payload

    payload.pop("timestamp", None)
    if response.ok:
        payload.pop("path", None)
        payload.pop("code", None)
        payload = payload['data']
        
    return payload


def read_file(file_path: Path) -> str:
    try:
        return file_path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return file_path.read_text(encoding="ascii", errors="ignore")


def _format_kv_block(obj: dict, indent: str = "  ") -> str:
    lines = []
    for k in sorted(obj.keys(), key=lambda x: str(x)):
        v = obj[k]
        if isinstance(v, (dict, list)):
            v_str = json.dumps(v, ensure_ascii=False)
        else:
            v_str = str(v)
        lines.append(f"{indent}{k}: {v_str}")
    return "\n".join(lines)


def _render_table_cell(value) -> str:
    if value is None:
        return "-"

    if isinstance(value, dict):
        if not value:
            return "{}"
        return _format_kv_block(value, indent="")

    if isinstance(value, list):
        if not value:
            return "-"

        if all(isinstance(x, dict) for x in value):
            blocks = []
            for i, item in enumerate(value, start=1):
                header = f"• #{i}"
                blocks.append(header)
                blocks.append(_format_kv_block(item, indent="  "))
            return "\n".join(blocks)

        lines = []
        for item in value:
            if isinstance(item, dict):
                lines.append("•")
                lines.append(_format_kv_block(item, indent="  "))
            elif isinstance(item, list):
                lines.append("• " + json.dumps(item, ensure_ascii=False))
            else:
                lines.append(f"• {item}")
        return "\n".join(lines)

    return str(value)

# def _render_table_cell(value) -> str:
#     if value is None:
#         return "-"

#     if isinstance(value, dict):
#         if not value:
#             return "{}"
#         return _format_kv_block(value, indent="")

#     if isinstance(value, list):
#         if not value:
#             return "(empty)"

#         # list[dict] -> każdy dict jako blok
#         if all(isinstance(x, dict) for x in value):
#             blocks = []
#             for i, item in enumerate(value, start=1):
#                 header = f"• #{i}"
#                 blocks.append(header)
#                 blocks.append(_format_kv_block(item, indent="  "))
#             return "\n".join(blocks)

#         lines = []
#         for index, item in enumerate(value):
#             is_last = len(value) == index + 1
#             new_line = ""
            
#             if isinstance(item, dict):
#                 #lines.append("•")
#                 new_line = _format_kv_block(item, indent="  ")
#             elif isinstance(item, list):
#                 new_line = json.dumps(item, ensure_ascii=False)
#             else:
#                 new_line = item
            
#             lines.append(f"{new_line}{", " if not is_last else ""}")
#         return "".join(lines)

#     return str(value)


def render(data, output: str):
    if output == "json":
        rprint(json.dumps(data, indent=2, ensure_ascii=False))
        return

    if output == "text":
        if isinstance(data, dict):
            for k, v in data.items():
                rprint(f"{k}: {v}")
        else:
            rprint(data)
        return

    if output == "table":
        rows = data if isinstance(data, list) else [data]
        if not rows:
            rprint("(empty)")
            return

        table = Table(show_header=True, header_style="bold", expand=True, show_lines=True)

        cols = list(rows[0].keys())
        for c in cols:
            table.add_column(str(c), overflow="fold")  # fold pomaga gdy jest dużo tekstu

        for row in rows:
            table.add_row(*[_render_table_cell(row.get(c, "")) for c in cols])

        console.print(table)
        return

    raise typer.BadParameter("output must be one of: json, text, table")


if __name__ == "__main__":
    app()
