#!/usr/bin/env python3

import json
import typer
import hmac
import hashlib
import base64
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich import print as rprint
from dataclasses import dataclass
from typing import Any, Optional, Dict
import requests

SETTINGS_FILE = Path("~/.certhub").expanduser()

# App

app = typer.Typer(
    add_completion=True, 
    help="CLI for managing certificates in Cert Hub"
)
cert_app = typer.Typer(help="Certificate commands, use 'certhub cert --help' for details")
token_app = typer.Typer(help="Token commands, add 'certhub token --help' for details")
app.add_typer(cert_app, name="cert")
app.add_typer(token_app, name="token")
console = Console()

@dataclass
class Settings:
    api_url: str | None
    token: str | None
    

@app.callback()
def main(
    ctx: typer.Context,
    api_url: str = typer.Option(
        None,
        "--base-url",
        envvar="CERT_REGISTRY_API_URL",
        help=f"API base URL. You can also set API_URL=<value> in {SETTINGS_FILE}.",
    ),
    token: str = typer.Option(
        None,
        "--token",
        envvar="CERT_REGISTRY_TOKEN",
        help=f"Bearer token. You can also set TOKEN=<value> in {SETTINGS_FILE}.",
    )
) -> None:
    ctx.obj = Settings(api_url=api_url, token=token)

# Client

@dataclass(frozen=True)
class Client():
    base_url: str
    session: requests.Session
    timeout: int
    
    @classmethod
    def init(cls, base_url: str, token: Optional[str] = None, *, timeout: int) -> "Client":
        base_url = base_url.rstrip("/")
        session = requests.Session()
        
        if token:
            session.headers.update({"Authorization": f"Bearer {token}"})

        session.headers.update({"Accept": "application/json"})
        
        try:
            session.request("GET", f"{base_url}/ping")
        except requests.RequestException as e:
            typer.secho(
                f"Error connecting to API server: {e}",
                fg=typer.colors.RED,
                err=True,
            )
            raise typer.Exit(code=1)

        return cls(base_url, session, timeout)
    
    
    def request(
        self, 
        method: str, 
        path: str, 
        *, 
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> requests.Response:
        url = f"{self.base_url}{path}"
        
        response = self.session.request(
            method=method.upper(),
            url=url,
            params=params,
            json=json_body,
            timeout=self.timeout
        )
        
        return response

# Commands

@app.command(help="Statuses for all certificates")
def health(
    ctx: typer.Context,
    exclude_ok: bool = typer.Option(
        None, "--exclude-ok", 
        help="Hide certificates with OK status"
    ),
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="Request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    params = {}
    if exclude_ok:
        params["exclude_ok"] = "true"
        
    response = client.request("GET", "/api/health", params=params)
    payload = parse_response(response) 
    
    if payload.get("certs"):
        payload = payload["certs"]
    
    render(payload, format)
    
    
@app.command(help="Versions and author")
def version(
    ctx: typer.Context,
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="Request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/version")
    payload = parse_response(response)
    
    render(payload, format)


@token_app.command(help="Permitted certificates for current identity")
def scope(
    ctx: typer.Context,
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="Request timeout in seconds"
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text"
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/scope")
    payload = parse_response(response)
    
    render(payload, format)
    
    
@token_app.command(help="Current identity information (e.g. allowed CIDRs, permissions)")
def identity(
    ctx: typer.Context,
    timeout: int = typer.Option(
        10, "--timeout", "-t", 
        help="Request timeout in seconds."
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text."
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/token/identity")
    payload = parse_response(response)
    
    if payload.get("permissions"):
        payload["permissions"] = [f"{p['scope']}:{p['action']}" for p in payload["permissions"]]
    
    render(payload, format)


@token_app.command(help="Generate TOKEN_<ID>_HMAC for server configuration") 
def generate_hmac(
    hmac_key_b64: str = typer.Option(
        ..., "--hmac-key-b64",
        help="Base64-encoded HMAC key (same value as server HMAC_KEY_B64)",
    ),
    token_id: str = typer.Option(
        ..., "--id", "-i",
        help="Identity ID used in Authorization token format: <id>.<token>",
    ),
    token_value: str = typer.Option(
        ..., "--token", "-t",
        help="Raw token value used as <token> in Authorization: Bearer <id>.<token>",
    )
) -> None:
    key = base64.b64decode(hmac_key_b64)
    token = str(token_value).encode()
    hmac_key = hmac.new(key, token, hashlib.sha256)
    print(f"Environment to setup in server:\nTOKEN_{str(token_id.upper())}_HMAC={hmac_key.hexdigest()}")


@cert_app.command(help="")
def issue(
    ctx: typer.Context,
    timeout: int = typer.Option(
        360, "--timeout", "-t", 
        help="Request timeout in seconds."
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text."
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)


@cert_app.command(help="")
def renew(
    ctx: typer.Context,
    timeout: int = typer.Option(
        360, "--timeout", "-t", 
        help="Request timeout in seconds."
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text."
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    

@cert_app.command(help="")
def get(
    ctx: typer.Context,
    timeout: int = typer.Option(
        360, "--timeout", "-t", 
        help="Request timeout in seconds."
    ),
    format: str = typer.Option(
        "table", "--format", "-f", 
        help="Output format: table, json, or text."
    )
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.api_url, token=settings.token, timeout=timeout)
    
    response = client.request("GET", "/api/certs")
    payload = parse_response(response)
    
    render(payload, format)
    

# Helper functions

def load_settings(ctx: typer.Context) -> Settings:
    settings = ctx.obj
    if not isinstance(settings, Settings):
        raise typer.Exit(code=2)
    
    file_settings: dict[str, str] = {}
    if SETTINGS_FILE.exists():
        file_mode = SETTINGS_FILE.stat().st_mode & 0o777
        if file_mode != 0o600:
            raise typer.BadParameter(f"Invalid permissions for {SETTINGS_FILE}: expected 'rw-------' (600), got {file_mode:o}, use command:\nchmod 600 {SETTINGS_FILE}")

        for line in read_file(SETTINGS_FILE).splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if "=" not in line:
                continue

            key, value = line.split("=", 1)
            file_settings[key.strip().upper()] = value.strip()

    if not settings.api_url:
        settings.api_url = file_settings.get("API_URL")
    if not settings.token:
        settings.token = file_settings.get("TOKEN")

    if not settings.api_url:
        raise typer.BadParameter(
            f"Provide --api-url, set CERT_REGISTRY_API_URL environment variable, or add API_URL=<value> in {SETTINGS_FILE}"
        )
    return settings


def parse_response(response: requests.Response) -> dict:
    try:
        payload = response.json()
    except ValueError:
        return {"message": response.text}

    if not isinstance(payload, dict):
        return payload

    payload.pop("timestamp", None)
    if response.ok:
        payload.pop("path", None)
        payload.pop("code", None)
        payload = payload['data']
        
    return payload


def read_file(file_path: Path) -> str:
    try:
        return file_path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return file_path.read_text(encoding="ascii", errors="ignore")


def _format_kv_block(obj: dict, indent: str = "  ") -> str:
    lines = []
    for k in sorted(obj.keys(), key=lambda x: str(x)):
        v = obj[k]
        if isinstance(v, (dict, list)):
            v_str = json.dumps(v, ensure_ascii=False)
        else:
            v_str = str(v)
        lines.append(f"{indent}{k}: {v_str}")
    return "\n".join(lines)


def _render_table_cell(value) -> str:
    if value is None:
        return "-"

    if isinstance(value, dict):
        if not value:
            return "{}"
        return _format_kv_block(value, indent="")

    if isinstance(value, list):
        if not value:
            return "-"

        # list[dict] -> każdy dict jako blok
        if all(isinstance(x, dict) for x in value):
            blocks = []
            for i, item in enumerate(value, start=1):
                header = f"• #{i}"
                blocks.append(header)
                blocks.append(_format_kv_block(item, indent="  "))
            return "\n".join(blocks)

        lines = []
        for item in value:
            if isinstance(item, dict):
                lines.append("•")
                lines.append(_format_kv_block(item, indent="  "))
            elif isinstance(item, list):
                lines.append("• " + json.dumps(item, ensure_ascii=False))
            else:
                lines.append(f"• {item}")
        return "\n".join(lines)

    return str(value)

# def _render_table_cell(value) -> str:
#     if value is None:
#         return "-"

#     if isinstance(value, dict):
#         if not value:
#             return "{}"
#         return _format_kv_block(value, indent="")

#     if isinstance(value, list):
#         if not value:
#             return "(empty)"

#         # list[dict] -> każdy dict jako blok
#         if all(isinstance(x, dict) for x in value):
#             blocks = []
#             for i, item in enumerate(value, start=1):
#                 header = f"• #{i}"
#                 blocks.append(header)
#                 blocks.append(_format_kv_block(item, indent="  "))
#             return "\n".join(blocks)

#         lines = []
#         for index, item in enumerate(value):
#             is_last = len(value) == index + 1
#             new_line = ""
            
#             if isinstance(item, dict):
#                 #lines.append("•")
#                 new_line = _format_kv_block(item, indent="  ")
#             elif isinstance(item, list):
#                 new_line = json.dumps(item, ensure_ascii=False)
#             else:
#                 new_line = item
            
#             lines.append(f"{new_line}{", " if not is_last else ""}")
#         return "".join(lines)

#     return str(value)


def render(data, output: str):
    if output == "json":
        rprint(json.dumps(data, indent=2, ensure_ascii=False))
        return

    if output == "text":
        if isinstance(data, dict):
            for k, v in data.items():
                rprint(f"{k}: {v}")
        else:
            rprint(data)
        return

    if output == "table":
        rows = data if isinstance(data, list) else [data]
        if not rows:
            rprint("(empty)")
            return

        table = Table(show_header=True, header_style="bold", expand=True, show_lines=True)

        cols = list(rows[0].keys())
        for c in cols:
            table.add_column(str(c), overflow="fold")  # fold pomaga gdy jest dużo tekstu

        for row in rows:
            table.add_row(*[_render_table_cell(row.get(c, "")) for c in cols])

        console.print(table)
        return

    raise typer.BadParameter("output must be one of: json, text, table")


if __name__ == "__main__":
    app()
