#!/usr/bin/env python3

import json
import typer
from rich.console import Console
from rich.table import Table
from rich import print as rprint
from dataclasses import dataclass
from typing import Any, Optional, Dict
import requests

#app = typer.Typer(add_completion=True, help="Cert registry CLI")
#cert_app = typer.Typer(help="Operacje na certyfikatach")
#app.add_typer(cert_app, name="cert")

app = typer.Typer(add_completion=True, help="CLI for Cert registry application used to issue/renew/get certificates generated by CertBot")
console = Console()

@dataclass
class Settings:
    base_url: str | None
    token: str | None
    

@app.callback()
def main(
    ctx: typer.Context,
    base_url: str = typer.Option(None, "--base-url", envvar="CERT_REGISTRY_URL"),
    token: str = typer.Option(None, "--token", envvar="CERT_REGISTRY_TOKEN")
) -> None:
    ctx.obj = Settings(base_url=base_url, token=token)


def load_settings(ctx: typer.Context) -> Settings:
    settings = ctx.obj
    if not isinstance(settings, Settings):
        raise typer.Exit(code=2)
    
    if not settings.base_url:
        raise typer.BadParameter("Provide parameter --base-url or set CERT_REGISTRY_URL environment variable")
    return settings

#
# Client
#

@dataclass(frozen=True)
class Client():
    base_url: str
    session: requests.Session
    timeout: int
    
    @classmethod
    def init(cls, base_url: str, token: Optional[str] = None, *, timeout: int) -> "Client":
        base_url = base_url.rstrip("/")
        session = requests.Session()
        
        if token:
            session.headers.update({"Authorization": f"Bearer {token}"})

        session.headers.update({"Accept": "application/json"})
        
        try:
            response = session.request("GET", f"{base_url}/ping")
        except requests.RequestException as e:
            typer.secho(
                f"API error ({e.response}): {e.response}",
                fg=typer.colors.RED,
                err=True,
            )
            raise typer.Exit(code=1)
        finally:
            # TODO
        return cls(base_url, session, timeout)
    
    
    def request(
        self, 
        method: str, 
        path: str, 
        *, 
        params: Optional[Dict[str, Any]] = None,
        json_body: Optional[Dict[str, Any]] = None,
    ) -> requests.Response:
        url = f"{self.base_url}{path}"
        
        response = self.session.request(
            method=method.upper(),
            url=url,
            params=params,
            json=json_body,
            timeout=self.timeout
        )
        
        return response

#
# Commands
#

@app.command()
def health(
    ctx: typer.Context,
    exclude_ok: bool = typer.Option(None, "--exclude-ok", help="Exclude healthy certificates from output"),
    timeout: int = typer.Option(10, "--timeout", "-t", help="Timeout for requests to API"),
    format: str = typer.Option("table", "--format", "-f", help="json|text|table")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.base_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/health")
    payload = get_response_payload(response) 
    
    if payload.get("certs"):
        payload = payload["certs"]
    
    render(payload, format)
    
    
@app.command()
def version(
    ctx: typer.Context,
    timeout: int = typer.Option(10, "--timeout", "-t", help="Timeout for requests to API"),
    format: str = typer.Option("table", "--format", "-f", help="json|text|table")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.base_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/version")
    payload = get_response_payload(response)
    
    render(payload, format)


@app.command()
def scope(
    ctx: typer.Context,
    timeout: int = typer.Option(10, "--timeout", "-t", help="Timeout for requests to API"),
    format: str = typer.Option("table", "--format", "-f", help="json|text|table")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.base_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/scope")
    payload = get_response_payload(response)
    
    render(payload, format)
    
    
@app.command()
def identity(
    ctx: typer.Context,
    timeout: int = typer.Option(10, "--timeout", "-t", help="Timeout for requests to API"),
    format: str = typer.Option("table", "--format", "-f", help="json|text|table")
) -> None:
    settings = load_settings(ctx)
    client = Client.init(base_url=settings.base_url, token=settings.token, timeout=timeout)
    response = client.request("GET", "/api/identity")
    payload = get_response_payload(response)
    
    if payload.get("permissions"):
        payload["permissions"] = [f"{p['scope']}:{p['action']}" for p in payload["permissions"]]
    
    render(payload, format)


@app.command() 
def generate_hmac_token() -> None:
    print('hmac_token')

#
# Helper functions
#

def get_response_payload(response: requests.Response) -> dict:
    try:
        payload = response.json()
    except ValueError:
        return {"message": response.text}

    if not isinstance(payload, dict):
        return payload

    payload.pop("timestamp", None)
    if response.ok:
        payload.pop("path", None)
        payload.pop("code", None)
        payload = payload['data']
        
    return payload

def _format_kv_block(obj: dict, indent: str = "  ") -> str:
    lines = []
    for k in sorted(obj.keys(), key=lambda x: str(x)):
        v = obj[k]
        if isinstance(v, (dict, list)):
            v_str = json.dumps(v, ensure_ascii=False)
        else:
            v_str = str(v)
        lines.append(f"{indent}{k}: {v_str}")
    return "\n".join(lines)


def _render_table_cell(value) -> str:
    if value is None:
        return "-"

    if isinstance(value, dict):
        if not value:
            return "{}"
        return _format_kv_block(value, indent="")

    if isinstance(value, list):
        if not value:
            return "(empty)"

        # list[dict] -> każdy dict jako blok
        if all(isinstance(x, dict) for x in value):
            blocks = []
            for i, item in enumerate(value, start=1):
                header = f"• #{i}"
                blocks.append(header)
                blocks.append(_format_kv_block(item, indent="  "))
            return "\n".join(blocks)

        lines = []
        for item in value:
            if isinstance(item, dict):
                lines.append("•")
                lines.append(_format_kv_block(item, indent="  "))
            elif isinstance(item, list):
                lines.append("• " + json.dumps(item, ensure_ascii=False))
            else:
                lines.append(f"• {item}")
        return "\n".join(lines)

    return str(value)

# def _render_table_cell(value) -> str:
#     if value is None:
#         return "-"

#     if isinstance(value, dict):
#         if not value:
#             return "{}"
#         return _format_kv_block(value, indent="")

#     if isinstance(value, list):
#         if not value:
#             return "(empty)"

#         # list[dict] -> każdy dict jako blok
#         if all(isinstance(x, dict) for x in value):
#             blocks = []
#             for i, item in enumerate(value, start=1):
#                 header = f"• #{i}"
#                 blocks.append(header)
#                 blocks.append(_format_kv_block(item, indent="  "))
#             return "\n".join(blocks)

#         lines = []
#         for index, item in enumerate(value):
#             is_last = len(value) == index + 1
#             new_line = ""
            
#             if isinstance(item, dict):
#                 #lines.append("•")
#                 new_line = _format_kv_block(item, indent="  ")
#             elif isinstance(item, list):
#                 new_line = json.dumps(item, ensure_ascii=False)
#             else:
#                 new_line = item
            
#             lines.append(f"{new_line}{", " if not is_last else ""}")
#         return "".join(lines)

#     return str(value)


def render(data, output: str):
    if output == "json":
        rprint(json.dumps(data, indent=2, ensure_ascii=False))
        return

    if output == "text":
        if isinstance(data, dict):
            for k, v in data.items():
                rprint(f"{k}: {v}")
        else:
            rprint(data)
        return

    if output == "table":
        rows = data if isinstance(data, list) else [data]
        if not rows:
            rprint("(empty)")
            return

        table = Table(show_header=True, header_style="bold", expand=True, show_lines=True)

        cols = list(rows[0].keys())
        for c in cols:
            table.add_column(str(c), overflow="fold")  # fold pomaga gdy jest dużo tekstu

        for row in rows:
            table.add_row(*[_render_table_cell(row.get(c, "")) for c in cols])

        console.print(table)
        return

    raise typer.BadParameter("output must be one of: json, text, table")


if __name__ == "__main__":
    app()
